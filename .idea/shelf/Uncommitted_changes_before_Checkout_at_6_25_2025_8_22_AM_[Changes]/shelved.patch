Index: PrintQueueManager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport threading\r\nfrom typing import Optional, List, Dict\r\n\r\n\r\nclass Job:\r\n    \"\"\"Represents a print job with all required metadata\"\"\"\r\n\r\n    def __init__(self, user_id: str, job_id: str, priority: int):\r\n        self.user_id = user_id\r\n        self.job_id = job_id\r\n        self.priority = priority\r\n        self.submission_time = time.time()\r\n        self.submission_time = time.time()\r\n        self.waiting_time = 0\r\n\r\n    def __str__(self):\r\n        return f\"Job({self.job_id}, User: {self.user_id}, Priority: {self.priority}, Wait: {self.waiting_time}s)\"\r\n\r\n\r\nclass PrintQueueManager:\r\n    \"\"\"Core Queue Management Module - Circular Queue Implementation\"\"\"\r\n\r\n    def __init__(self, max_capacity: int = 10):\r\n        # Circular queue with fixed capacity\r\n        self.max_capacity = max_capacity\r\n        self.queue = [None] * max_capacity\r\n        self.front = 0\r\n        self.rear = -1\r\n        self.size = 0\r\n\r\n        # Thread safety for concurrent operations\r\n        self.lock = threading.Lock()\r\n\r\n        # Job tracking for metadata management\r\n        self.active_jobs: Dict[str, Job] = {}\r\n\r\n    def enqueue_job(self, user_id: str, job_id: str, priority: int) -> bool:\r\n        \"\"\"\r\n        Add a new print job to the queue\r\n\r\n        Args:\r\n            user_id: ID of the user submitting the job\r\n            job_id: Unique identifier for the job\r\n            priority: Initial priority of the job\r\n\r\n        Returns:\r\n            bool: True if successful, False if queue is full or job exists\r\n        \"\"\"\r\n        with self.lock:\r\n            # Check if queue is full\r\n            if self.size >= self.max_capacity:\r\n                print(f\"Queue is full! Cannot add job {job_id}\")\r\n                return False\r\n\r\n            # Check for duplicate job IDs\r\n            if job_id in self.active_jobs:\r\n                print(f\"Job {job_id} already exists!\")\r\n                return False\r\n\r\n            # Create new job with metadata\r\n            job = Job(user_id, job_id, priority)\r\n\r\n            # Add to circular queue\r\n            self.rear = (self.rear + 1) % self.max_capacity\r\n            self.queue[self.rear] = job\r\n            self.size += 1\r\n\r\n            # Track in active jobs\r\n            self.active_jobs[job_id] = job\r\n\r\n            print(f\"Job {job_id} from user {user_id} enqueued (Priority: {priority})\")\r\n            return True\r\n\r\n    def dequeue_job(self) -> Optional[Job]:\r\n        \"\"\"\r\n        Remove and return the next job from the queue\r\n\r\n        Returns:\r\n            Job: The next job to process, or None if queue is empty\r\n        \"\"\"\r\n        with self.lock:\r\n            if self.size == 0:\r\n                return None\r\n\r\n            # Get job from front of circular queue\r\n            job = self.queue[self.front]\r\n            self.queue[self.front] = None\r\n\r\n            # Update circular queue pointers\r\n            self.front = (self.front + 1) % self.max_capacity\r\n            self.size -= 1\r\n\r\n            # Remove from active jobs tracking\r\n            if job and job.job_id in self.active_jobs:\r\n                del self.active_jobs[job.job_id]\r\n\r\n            return job\r\n\r\n    def print_job(self) -> bool:\r\n        \"\"\"\r\n        Process/print the next job in the queue\r\n\r\n        Returns:\r\n            bool: True if a job was printed, False if queue is empty\r\n        \"\"\"\r\n        job = self.dequeue_job()\r\n        if job is None:\r\n            print(\"No jobs in queue to print\")\r\n            return False\r\n\r\n        print(f\"PRINTING: {job}\")\r\n        return True\r\n\r\n    def show_status(self):\r\n        \"\"\"Display current queue status and all jobs\"\"\"\r\n        with self.lock:\r\n            print(\"\\n\" + \"=\" * 50)\r\n            print(\"PRINT QUEUE STATUS\")\r\n            print(\"=\" * 50)\r\n            print(f\"Queue Size: {self.size}/{self.max_capacity}\")\r\n            print(\r\n                f\"Queue State: {'EMPTY' if self.size == 0 else 'FULL' if self.size == self.max_capacity else 'ACTIVE'}\")\r\n\r\n            if self.size > 0:\r\n                print(f\"\\nJobs in Queue (Print Order):\")\r\n                print(\"-\" * 50)\r\n\r\n                # Display jobs in order from front to rear\r\n                current = self.front\r\n                for i in range(self.size):\r\n                    job = self.queue[current]\r\n                    if job:\r\n                        print(f\"{i + 1:2d}. {job}\")\r\n                    current = (current + 1) % self.max_capacity\r\n            else:\r\n                print(\"\\nNo jobs in queue\")\r\n\r\n            print(\"=\" * 50 + \"\\n\")\r\n\r\n    # Helper methods for other modules to use\r\n    def is_empty(self) -> bool:\r\n        \"\"\"Check if queue is empty\"\"\"\r\n        return self.size == 0\r\n\r\n    def is_full(self) -> bool:\r\n        \"\"\"Check if queue is full\"\"\"\r\n        return self.size >= self.max_capacity\r\n\r\n    def get_all_jobs(self) -> List[Job]:\r\n        \"\"\"Get all jobs in queue order (for other modules)\"\"\"\r\n        with self.lock:\r\n            jobs = []\r\n            if self.size == 0:\r\n                return jobs\r\n\r\n            current = self.front\r\n            for _ in range(self.size):\r\n                if self.queue[current]:\r\n                    jobs.append(self.queue[current])\r\n                current = (current + 1) % self.max_capacity\r\n            return jobs\r\n\r\n\r\n# Test the module\r\nif __name__ == \"__main__\":\r\n    # Create queue manager\r\n    pq_manager = PrintQueueManager(max_capacity=5)\r\n\r\n    print(\"Testing Module 1 - Core Queue Management\")\r\n    print(\"=\" * 45)\r\n\r\n    # Test enqueue operations\r\n    pq_manager.enqueue_job(\"user1\", \"job1\", 3)\r\n    pq_manager.enqueue_job(\"user2\", \"job2\", 1)\r\n    pq_manager.enqueue_job(\"user1\", \"job3\", 5)\r\n\r\n    # Show current status\r\n    pq_manager.show_status()\r\n\r\n    # Test print operation\r\n    pq_manager.print_job()\r\n    pq_manager.show_status()\r\n\r\n    # Test queue full scenario\r\n    print(\"Testing queue capacity limits...\")\r\n    for i in range(4, 8):\r\n        pq_manager.enqueue_job(f\"user{i}\", f\"job{i}\", i)\r\n\r\n    pq_manager.show_status()
===================================================================
diff --git a/PrintQueueManager.py b/PrintQueueManager.py
--- a/PrintQueueManager.py	(revision f2b9038e5e828fbb789af2665ba64b076a05b9c4)
+++ b/PrintQueueManager.py	(date 1750753010505)
@@ -11,7 +11,7 @@
         self.job_id = job_id
         self.priority = priority
         self.submission_time = time.time()
-        self.submission_time = time.time()
+
         self.waiting_time = 0
 
     def __str__(self):
